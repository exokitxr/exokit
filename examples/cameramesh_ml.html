<html>
  <head>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
  <script src="three.js"></script>
  <!-- <script src="inflate.min.js"></script>
  <script src="FBXLoader.js"></script> -->
  <script>
    let container, scene, camera, display;
    let mesher = null, cameraMesher = null, cameraMeshTexture, cameraMeshTexture2/*, planeMesh, planeMesh2*/;

    const localVector = new THREE.Vector3();
    const localVector2 = new THREE.Vector3();
    const localQuaternion = new THREE.Quaternion();
    const localMatrix = new THREE.Matrix4();

    const _requestImage = src => new Promise((accept, reject) => {
      const img = new Image();
      img.src = src;
      img.onload = () => {
        accept(img);
      };
      img.onerror = err => {
        reject(err);
      };
    });

    function init() {
      container = document.createElement('div');
      document.body.appendChild(container);

      scene = new THREE.Scene();
      scene.matrixAutoUpdate = false;
      // scene.background = new THREE.Color(0x3B3961);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      // camera.position.set(0, 1, 0);
      camera.lookAt(new THREE.Vector3());
      scene.add(camera);

      const ambientLight = new THREE.AmbientLight(0x808080);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      /* (() => {
        const geometry = new THREE.BoxBufferGeometry(0.1, 1, 0.1);
        const material = new THREE.MeshPhongMaterial({
          color: 0xE91E63,
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 0.5;
        // mesh.position.z = -1;
        mesh.frustumCuled = false;
        scene.add(mesh);
      })();
      (() => {
        const geometry = new THREE.BoxBufferGeometry(0.1, 0.1, 0.1);
        const material = new THREE.MeshPhongMaterial({
          color: 0x4CAF50,
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 1 + 0.1;
        // mesh.position.z = -1;
        mesh.frustumCulled = false;
        scene.add(mesh);
      })(); */

      const handMesh = (() => {
        const pointerGeometry = new THREE.CylinderBufferGeometry(0.001, 0.001, 1, 32, 1)
          .applyMatrix(localMatrix.makeTranslation(0, 1/2, 0))
          .applyMatrix(localMatrix.makeRotationFromQuaternion(
            localQuaternion.setFromUnitVectors(
              localVector.set(0, 1, 0),
              localVector2.set(0, 0, -1)
            )
          ));
        const boneGeometry = new THREE.BoxBufferGeometry(0.005, 0.005, 0.005);

        const geometry = new THREE.BufferGeometry();

        const positions = new Float32Array(boneGeometry.attributes.position.array.length * 2 * 6 * 4 + pointerGeometry.attributes.position.array.length * 2);
        const positionAttribute = new THREE.BufferAttribute(positions, 3);
        geometry.addAttribute('position', positionAttribute);

        const indices = new Uint16Array(boneGeometry.index.array.length * 2 * 6 * 4 + pointerGeometry.index.array.length * 2);
        const indexAttribute = new THREE.BufferAttribute(indices, 1);
        geometry.setIndex(indexAttribute);

        const material =  new THREE.MeshPhongMaterial({
          color: 0xFF0000,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.update = hands => {
          let positionIndex = 0;
          let indexIndex = 0;

          const _shiftIndex = array => {
            for (let l = 0; l < array.length; l++) {
              array[l] += positionIndex / 3;
            }
          };

          for (let i = 0; i < hands.length; i++) {
            const hand = hands[i];
            const {pointer, grip, wrist, fingers} = hand;
            const allFingers = [wrist].concat(fingers);
            for (let j = 0; j < allFingers.length; j++) {
              const bones = allFingers[j];
              for (let k = 0; k < bones.length; k++) {
                const positionFloat32Array = bones[k];
                if (positionFloat32Array) {
                  const position = localVector.fromArray(positionFloat32Array);
                  const newGeometry = boneGeometry.clone()
                    .applyMatrix(
                      localMatrix.makeTranslation(position.x, position.y, position.z)
                    );

                  _shiftIndex(newGeometry.index.array);

                  positions.set(newGeometry.attributes.position.array, positionIndex);
                  positionIndex += newGeometry.attributes.position.array.length;

                  indices.set(newGeometry.index.array, indexIndex);
                  indexIndex += newGeometry.index.array.length;
                }
              }
            }

            if (pointer) {
              const newGeometry = pointerGeometry.clone()
                .applyMatrix(
                  localMatrix.compose(
                    localVector.fromArray(pointer.position),
                    localQuaternion.fromArray(pointer.rotation),
                    localVector2.set(1, 1, 1),
                  )
                );

              _shiftIndex(newGeometry.index.array);

              positions.set(newGeometry.attributes.position.array, positionIndex);
              positionIndex += newGeometry.attributes.position.array.length;

              indices.set(newGeometry.index.array, indexIndex);
              indexIndex += newGeometry.index.array.length;
            }

            if (grip) {
              const newGeometry = pointerGeometry.clone()
                .applyMatrix(
                  localMatrix.compose(
                    localVector.fromArray(grip.position),
                    localQuaternion.fromArray(grip.rotation),
                    localVector2.set(1, 1, 1),
                  )
                );

              _shiftIndex(newGeometry.index.array);

              positions.set(newGeometry.attributes.position.array, positionIndex);
              positionIndex += newGeometry.attributes.position.array.length;

              indices.set(newGeometry.index.array, indexIndex);
              indexIndex += newGeometry.index.array.length;
            }
          }

          positionAttribute.needsUpdate = true;
          indexAttribute.needsUpdate = true;
          geometry.setDrawRange(0, indexIndex);
        };
        mesh.visible = false;
        mesh.frustumCulled = false;
        return mesh;
      })();
      scene.add(handMesh);
      const _onHands = hands => {
        handMesh.update(hands);
      };

      const terrainMeshes = [];
      const terrainMaterial = (() => {
        /* const baseTexture = new THREE.Texture(
          null,
          THREE.UVMapping,
          THREE.ClampToEdgeWrapping,
          THREE.ClampToEdgeWrapping,
          THREE.NearestFilter,
          THREE.NearestFilter,
          THREE.RGBAFormat,
          THREE.UnsignedByteType,
          16
        );
        _requestImage('checkerboard.png')
          .then(checkerboardImg => {
            baseTexture.image = checkerboardImg;
            baseTexture.needsUpdate = true;
          }); */

        const material = new THREE.ShaderMaterial({
          uniforms: {
            map: {
              type: 't',
              // value: baseTexture,
              value: null,
            },
          },
          vertexShader: `\
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `\
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              gl_FragColor = texture2D(map, vUv);
            }
          `,
        });
        return material;
      })();
      const _getTerrainMesh = meshId => {
        let terrainMesh = terrainMeshes.find(terrainMesh => terrainMesh.meshId === meshId);
        if (!terrainMesh) {
          terrainMesh = _makeTerrainMesh(meshId);
          terrainMeshes.push(terrainMesh);
          scene.add(terrainMesh);
        }
        return terrainMesh;
      };
      const fakeArrayBuffer = new ArrayBuffer(3 * 4);
      const fakeFloat32Array = new Float32Array(fakeArrayBuffer, 0, 3);
      const fakeUint16Array = new Uint16Array(fakeArrayBuffer, 0, 3);
      const planeGeometry = new THREE.PlaneBufferGeometry(0.2, 0.2)
        .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.2/2, 0));
      const _makePlaneMesh = () => {
        const geometry = planeGeometry;
        const material = new THREE.ShaderMaterial({
          vertexShader: `\
            void main() {
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `\
            void main() {
              gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
          `,
          // side: THREE.DoubleSide, // XXX this matters
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.frustumCulled = false;
        return mesh;
      };
      const _makeTerrainMesh = meshId => {
        const geometry = new THREE.BufferGeometry();
        const gl = renderer.getContext();
        const attributes = renderer.getAttributes();

        geometry.addAttribute('position', new THREE.BufferAttribute(fakeFloat32Array, 3));
        attributes.update(geometry.attributes.position, gl.ARRAY_BUFFER);
        geometry.addAttribute('uv', new THREE.BufferAttribute(fakeFloat32Array, 2));
        attributes.update(geometry.attributes.uv, gl.ARRAY_BUFFER);

        const map = new THREE.Texture(
          null,
          THREE.UVMapping,
          THREE.ClampToEdgeWrapping,
          THREE.ClampToEdgeWrapping,
          THREE.NearestFilter,
          THREE.NearestFilter,
          THREE.RGBAFormat,
          THREE.UnsignedByteType,
          16
        );
        const material = new THREE.ShaderMaterial({
          uniforms: {
            map: {
              type: 't',
              value: map,
            },
          },
          vertexShader: `\
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `\
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              gl_FragColor = texture2D(map, vUv);
            }
          `,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.meshId = meshId;
        mesh.frustumCulled = false;

        /* const planeMesh = _makePlaneMesh();
        mesh.add(planeMesh);
        mesh.planeMesh = planeMesh; */

        return mesh;
      };
      const _loadTerrainMesh = (terrainMesh, {positionBuffer, positionCount, vertexBuffer, vertexCount, uvBuffer, uvCount, texture, textureData}) => {
        const {geometry, material} = terrainMesh;
        const attributes = renderer.getAttributes();

        attributes.get(geometry.attributes.position).buffer = vertexBuffer;
        geometry.attributes.position.count = vertexCount / 3;

        attributes.get(geometry.attributes.uv).buffer = uvBuffer;
        geometry.attributes.uv.count = uvCount / 2;

        if (texture) {
          const textureProperties1 = renderer.properties.get(terrainMesh.material.uniforms.map.value);
          textureProperties1.__webglInit = true;
          textureProperties1.__webglTexture = texture;
        } else {
          const textureProperties1 = renderer.properties.get(terrainMesh.material.uniforms.map.value);
          textureProperties1.__webglInit = false;
          textureProperties1.__webglTexture = null;
        }

        if (textureData) {
          console.log('got texture data', textureData.length);
        }
      };
      const _removeTerrainMesh = terrainMesh => {
        scene.remove(terrainMesh);
        // terrainMesh.geometry.dispose();
        terrainMesh.textureMaterial.dispose();
      };
      const _clearTerrainMeshes = () => {
        for (let i = 0; i < terrainMeshes.length; i++) {
          _removeTerrainMesh(terrainMeshes[i]);
        }
        terrainMeshes.length = 0;
      };
      const _onMesh = updates => {
        for (let i = 0; i < updates.length; i++) {
          const update = updates[i];
          const {id, type} = update;

          if (type === 'new' || type === 'update') {
            _loadTerrainMesh(_getTerrainMesh(id), update);
          } else if (type === 'unchanged') {
            // nothing
          } else {
            const index = terrainMeshes.findIndex(terrainMesh => terrainMesh.meshId === id);
            if (index !== -1) {
              const terrainMesh = terrainMeshes[index];
              _removeTerrainMesh(terrainMesh);
              terrainMeshes.splice(index, 1);
            }
          }
        }
      };
      const _onCameraMesh = updates => {
        for (let i = 0; i < updates.length; i++) {
          const update = updates[i];
          const {id} = update;

          // _loadTerrainMesh(_getTerrainMesh(id), update); // XXX
        }
      };

      cameraMeshTexture = new THREE.Texture(
        null,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping,
        THREE.ClampToEdgeWrapping,
        THREE.NearestFilter,
        THREE.NearestFilter,
        THREE.RGBAFormat,
        THREE.UnsignedByteType,
        16
      );
      cameraMeshTexture2 = new THREE.Texture(
        null,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping,
        THREE.ClampToEdgeWrapping,
        THREE.NearestFilter,
        THREE.NearestFilter,
        THREE.RGBAFormat,
        THREE.UnsignedByteType,
        16
      );
      /* const material = new THREE.ShaderMaterial({
        uniforms: {
          cameraMeshTexture: {
            type: 't',
            value: cameraMeshTexture,
          },
        },
        vertexShader: `\
          varying vec2 vUv;
          // varying vec2 vPosition;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            // vPosition = vec2(mod(position.x, 0.1), mod(position.y, 0.1));
          }
        `,
        fragmentShader: `\
          uniform sampler2D cameraMeshTexture;
          varying vec2 vUv;
          // varying vec2 vPosition;
          void main() {
            // gl_FragColor = texture2D(cameraMeshTexture, vPosition);
            gl_FragColor = texture2D(cameraMeshTexture, vUv);
            // gl_FragColor = vec4(1.0, vUv.x, vUv.x, 1.0);
          }
        `,
      }); */
      /* planeMesh = new THREE.Mesh(
        new THREE.PlaneBufferGeometry(0.2, 0.2)
          .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.2/2, 0)),
        new THREE.MeshBasicMaterial({
          map: cameraMeshTexture,
        })
      );
      planeMesh.frustumCulled = false;
      scene.add(planeMesh);

      planeMesh2 = new THREE.Mesh(
        new THREE.PlaneBufferGeometry(0.2, 0.2)
          .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.2/2, 0)),
        new THREE.MeshBasicMaterial({
          map: cameraMeshTexture2,
        })
      );
      planeMesh2.frustumCulled = false;
      scene.add(planeMesh2); */

      let enabled = false;
      const _enable = () => {
        mesher = window.browser.magicleap.RequestMeshing();
        mesher.onmesh = _onMesh;

        cameraMesher = window.browser.magicleap.RequestCameraMeshing();
        cameraMesher.onmesh = _onCameraMesh;

        enabled = true;
      };
      const _disable = () => {
        mesher.destroy();
        mesher = null;
        cameraMesher.destroy();
        cameraMesher = null;
        _clearTerrainMeshes();

        enabled = false;
      };
      _enable();
      window.addEventListener('keydown', e => {
        if (e.keyCode === 13) { // enter
          if (enabled) {
            _disable();
          } else {
            _enable();
          }
        }
      });

      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);

      // window.browser.magicleap.RequestDepthPopulation(true);
      // renderer.autoClear = false;

      container.appendChild(renderer.domElement);

      renderer.setAnimationLoop(animate);
    }

    function animate(time, frame) {
      /* if (renderer.vr.enabled) {
        const inputSources = display.session.getInputSources();

        for (let i = 0; i < inputSources.length; i++) {
          const inputSource = inputSources[i];
          const pose = frame.getInputPose(inputSource);

          if (i === 0) { // left
            planeMesh.matrix.fromArray(pose.pointerMatrix);
            planeMesh.matrix.decompose(planeMesh.position, planeMesh.quaternion, planeMesh.scale);
            planeMesh.updateMatrixWorld(true);

            planeMesh2.matrix.fromArray(pose.pointerMatrix);
            planeMesh2.matrix.decompose(planeMesh2.position, planeMesh2.quaternion, planeMesh2.scale);
            planeMesh2.position.add(
              localVector.set(0.2, 0, 0)
                .applyQuaternion(planeMesh2.quaternion)
            );
            planeMesh2.matrix.compose(planeMesh2.position, planeMesh2.quaternion, planeMesh2.scale);
            planeMesh2.updateMatrixWorld(true);
          }
        }
      } */

      renderer.render(scene, renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera);
    }

    init();

    (async () => {
      console.log('request device');
      display = await navigator.xr.requestDevice();
      console.log('request session');
      const session = await display.requestSession({
        exclusive: true,
      });
      display.session = session;

      // console.log('request first frame');
      session.requestAnimationFrame((timestamp, frame) => {
        renderer.vr.setSession(session, {
          frameOfReferenceType: 'stage',
        });

        const viewport = session.baseLayer.getViewport(frame.views[0]);
        const width = viewport.width;
        const height = viewport.height;

        renderer.setSize(width * 2, height);

        renderer.setAnimationLoop(null);

        renderer.vr.enabled = true;
        renderer.vr.setDevice(display);
        renderer.vr.setAnimationLoop(animate);

        console.log('running!');
      });
    })();

    /* (() => {
      const framesData = [];

      const server = window.browser.http.createServer((req, res) => {
        console.log('got request', req.url);

        let match;
        if (req.url === '/') {
          res.statusCode = 302;
          res.setHeader('Location', '/examples/camera_client.html');
          res.end();
        } else if (match = req.url.match(/\.(html|js)$/)) {
          fetch('file:///package' + req.url)
            .then(proxyRes => {
              if (proxyRes.ok) {
                return proxyRes.arrayBuffer()
                  .then(arrayBuffer => {
                    const type = (() => {
                      switch (match[1]) {
                        case 'html': return 'text/html';
                        case 'js': return 'application/javascript';
                        default: return 'text/plain';
                      }
                    })();
                    res.setHeader('Content-Type', type);

                    const buffer = Buffer.from(arrayBuffer);
                    res.end(buffer);
                  });
              } else {
                res.statusCode = proxyRes.status;
                res.end();
                return null;
              }
            })
            .catch(err => {
              console.warn(err.stack);
              res.statusCode = 500;
              res.end();
            });
        } else if (match = req.url.match(/^\/frame\/([0-9]+)$/)) {
          const frameId = parseInt(match[1], 10);
          const frameData = framesData[frameId];
          if (frameData) {
            console.log('send frame data', typeof frameData, frameData.constructor && frameData.constructor.name, frameData && frameData.length);
            res.setHeader('Content-Type', 'application/octet-stream');
            res.end(frameData);
          } else {
            res.statusCode = 404;
            res.end();
          }
        } else {
          res.statusCode = 404;
          res.end();
        }
      });

      const wss = new window.browser.ws.Server({
        server,
      });
      wss.on('connection', (c, request) => {
        console.log('open connection');

        const _onCameraFrame = a => {
          console.log('camera frame', a.length, c.readyState === window.browser.ws.OPEN);
          if (c.readyState === window.browser.ws.OPEN) {
            const updates = a.map((e, i) => {
              const {width, height, bpp, stride, data} = e;
              framesData[i] = Buffer.from(data);
              return {
                index: i,
                width,
                height,
                bpp,
                stride,
              };
            });
            c.send(JSON.stringify(updates));
          }
        };
        window.browser.magicleap.RequestCamera(_onCameraFrame);

        c.on('close', () => {
          console.log('close connection 1');
          framesData.length = 0;
          console.log('close connection 2');
          window.browser.magicleap.CancelCamera(_onCameraFrame);
          console.log('close connection 3');
        });
      });

      server.listen(7999, '0.0.0.0', () => {
        console.log('listening');
      });
      server.on('error', err => {
        console.warn('server error', err.stack);
      });
    })(); */
  </script>
  </body>
</html>
