<html>
  <head>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
  <script src="three.js"></script>
  <!-- <script src="inflate.min.js"></script>
  <script src="FBXLoader.js"></script> -->
  <script>
(() => {
    let container, scene, camera, display;
    let mesher = null, cameraMesher = null, connections = [], terrainMeshData = {};

    const localVector = new THREE.Vector3();
    const localVector2 = new THREE.Vector3();
    const localQuaternion = new THREE.Quaternion();
    const localMatrix = new THREE.Matrix4();

    const _requestImage = src => new Promise((accept, reject) => {
      const img = new Image();
      img.src = src;
      img.onload = () => {
        accept(img);
      };
      img.onerror = err => {
        reject(err);
      };
    });

    function init() {
      container = document.createElement('div');
      document.body.appendChild(container);

      scene = new THREE.Scene();
      scene.matrixAutoUpdate = false;
      // scene.background = new THREE.Color(0x3B3961);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      // camera.position.set(0, 1, 0);
      camera.lookAt(new THREE.Vector3());
      scene.add(camera);

      const ambientLight = new THREE.AmbientLight(0x808080);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      /* (() => {
        const geometry = new THREE.BoxBufferGeometry(0.1, 1, 0.1);
        const material = new THREE.MeshPhongMaterial({
          color: 0xE91E63,
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 0.5;
        // mesh.position.z = -1;
        mesh.frustumCuled = false;
        scene.add(mesh);
      })();
      (() => {
        const geometry = new THREE.BoxBufferGeometry(0.1, 0.1, 0.1);
        const material = new THREE.MeshPhongMaterial({
          color: 0x4CAF50,
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 1 + 0.1;
        // mesh.position.z = -1;
        mesh.frustumCulled = false;
        scene.add(mesh);
      })(); */

      const terrainMeshes = [];
      const _getTerrainMesh = meshId => {
        let terrainMesh = terrainMeshes.find(terrainMesh => terrainMesh.meshId === meshId);
        if (!terrainMesh) {
          terrainMesh = _makeTerrainMesh(meshId);
          terrainMeshes.push(terrainMesh);
          scene.add(terrainMesh);
        }
        return terrainMesh;
      };
      const fakeArrayBuffer = new ArrayBuffer(3 * 4);
      const fakeFloat32Array = new Float32Array(fakeArrayBuffer, 0, 3);
      const fakeUint16Array = new Uint16Array(fakeArrayBuffer, 0, 3);
      const _makeTerrainMesh = meshId => {
        const geometry = new THREE.BufferGeometry();
        const gl = renderer.getContext();
        const attributes = renderer.getAttributes();

        geometry.addAttribute('position', new THREE.BufferAttribute(fakeFloat32Array, 3));
        attributes.update(geometry.attributes.position, gl.ARRAY_BUFFER);
        geometry.addAttribute('uv', new THREE.BufferAttribute(fakeFloat32Array, 2));
        attributes.update(geometry.attributes.uv, gl.ARRAY_BUFFER);

        const map = new THREE.Texture(
          null,
          THREE.UVMapping,
          THREE.ClampToEdgeWrapping,
          THREE.ClampToEdgeWrapping,
          THREE.NearestFilter,
          THREE.NearestFilter,
          THREE.RGBFormat,
          THREE.UnsignedByteType,
          16
        );
        /* const material = new THREE.MeshBasicMaterial({
          map,
        }); */
        const material = new THREE.ShaderMaterial({
          uniforms: {
            map: {
              type: 't',
              value: map,
            },
          },
          vertexShader: `\
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `\
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              gl_FragColor = texture2D(map, vUv);
            }
          `,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.meshId = meshId;
        mesh.frustumCulled = false;

        return mesh;
      };
      const _loadTerrainMesh = (terrainMesh, {vertexBuffer, vertexCount, uvBuffer, uvCount, texture, textureData}) => {
        const {geometry, material} = terrainMesh;
        const attributes = renderer.getAttributes();

        attributes.get(geometry.attributes.position).buffer = vertexBuffer;
        geometry.attributes.position.count = vertexCount / 3;

        attributes.get(geometry.attributes.uv).buffer = uvBuffer;
        geometry.attributes.uv.count = uvCount / 2;

        if (texture) {
          const textureProperties1 = renderer.properties.get(terrainMesh.material.uniforms.map.value);
          textureProperties1.__webglInit = true;
          textureProperties1.__webglTexture = texture;
        } else {
          const textureProperties1 = renderer.properties.get(terrainMesh.material.uniforms.map.value);
          textureProperties1.__webglInit = false;
          textureProperties1.__webglTexture = null;
        }

        if (textureData) {
          console.log('got texture data', textureData.length);
        }
      };
      const _removeTerrainMesh = terrainMesh => {
        scene.remove(terrainMesh);
        // terrainMesh.geometry.dispose();
        terrainMesh.textureMaterial.dispose();
      };
      const _clearTerrainMeshes = () => {
        for (let i = 0; i < terrainMeshes.length; i++) {
          _removeTerrainMesh(terrainMeshes[i]);
        }
        terrainMeshes.length = 0;
      };
      const _loadTerrainData = ({id, vertexArray, vertexCount, uvArray, uvCount, textureData}) => {
        const dataArray = new ArrayBuffer(
          Uint32Array.BYTES_PER_ELEMENT + vertexCount * Float32Array.BYTES_PER_ELEMENT +
          Uint32Array.BYTES_PER_ELEMENT + uvCount * Float32Array.BYTES_PER_ELEMENT +
          Uint32Array.BYTES_PER_ELEMENT + textureData.length * Uint8Array.BYTES_PER_ELEMENT
        );

        let i = 0;
        new Uint32Array(dataArray, i, 1)[0] = vertexCount;
        i += Uint32Array.BYTES_PER_ELEMENT;
        new Float32Array(dataArray, i, vertexCount).set(vertexArray);
        i += Float32Array.BYTES_PER_ELEMENT * vertexCount;

        new Uint32Array(dataArray, i, 1)[0] = uvCount;
        i += Uint32Array.BYTES_PER_ELEMENT;
        new Float32Array(dataArray, i, uvCount).set(uvArray);
        i += Float32Array.BYTES_PER_ELEMENT * uvCount;

        if (textureData) {
          new Uint32Array(dataArray, i, 1)[0] = textureData.length;
          i += Uint32Array.BYTES_PER_ELEMENT;
          new Uint8Array(dataArray, i, textureData.length).set(textureData);
          i += Uint8Array.BYTES_PER_ELEMENT * textureData.length;
        } else {
          new Uint32Array(dataArray, i, 1)[0] = 0;
          i += Uint32Array.BYTES_PER_ELEMENT;
        }

        terrainMeshData[id] = dataArray;
      };
      const _removeTerrainData = id => {
        terrainMeshData[id] = null;
      };
      const _onMesh = updates => {
        for (let i = 0; i < updates.length; i++) {
          const update = updates[i];
          const {id, type} = update;

          if (type === 'new' || type === 'update') {
            _loadTerrainMesh(_getTerrainMesh(id), update);
            _loadTerrainData(update);

            if (connections.length > 0) {
              const updateSpecs = [
                JSON.stringify({
                  method: 'mesh',
                  type,
                  id,
                }),
                terrainMeshData[id],
              ];

              for (let i = 0; i < connections.length; i++) {
                const c = connections[i];

                if (c.readyState === window.browser.ws.OPEN) {
                  for (let j = 0; j < updateSpecs.length; j++) {
                    c.send(updateSpecs[j]);
                  }
                }
              }
            }
          } else if (type === 'unchanged') {
            // nothing
          } else if (type === 'remove') {
            const index = terrainMeshes.findIndex(terrainMesh => terrainMesh.meshId === id);
            if (index !== -1) {
              const terrainMesh = terrainMeshes[index];
              _removeTerrainMesh(terrainMesh);
              terrainMeshes.splice(index, 1);

              _removeTerrainData(id);

              if (connections.length > 0) {
                const updateSpecs = [
                  JSON.stringify({
                    method: 'mesh',
                    type: 'remove',
                    id,
                  }),
                ];

                for (let i = 0; i < connections.length; i++) {
                  const c = connections[i];

                  if (c.readyState === window.browser.ws.OPEN) {
                    for (let j = 0; j < updateSpecs.length; j++) {
                      c.send(updateSpecs[j]);
                    }
                  }
                }
              }
            }
          } else {
            console.warn('got invalid mesh type', method);
          }
        }
      };
      const _onCameraMesh = updates => {
        for (let i = 0; i < updates.length; i++) {
          const update = updates[i];
          const {id, textureData} = update;

          if (textureData) {
            _loadTerrainMesh(_getTerrainMesh(id), update);
            _loadTerrainData(update);

            if (connections.length > 0) {
              const updateSpecs = [
                JSON.stringify({
                  method: 'mesh',
                  type: 'update',
                  id,
                }),
                terrainMeshData[id],
              ];

              for (let i = 0; i < connections.length; i++) {
                const c = connections[i];

                if (c.readyState === window.browser.ws.OPEN) {
                  for (let j = 0; j < updateSpecs.length; j++) {
                    c.send(updateSpecs[j]);
                  }
                }
              }
            }
          }
        }
      };

      let enabled = false;
      const _enable = () => {
        mesher = window.browser.magicleap.RequestMeshing();
        mesher.onmesh = _onMesh;

        cameraMesher = window.browser.magicleap.RequestCameraMeshing();
        cameraMesher.onmesh = _onCameraMesh;

        enabled = true;
      };
      const _disable = () => {
        mesher.destroy();
        mesher = null;
        cameraMesher.destroy();
        cameraMesher = null;
        _clearTerrainMeshes();

        enabled = false;
      };
      _enable();

      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);

      // window.browser.magicleap.RequestDepthPopulation(true);
      // renderer.autoClear = false;

      container.appendChild(renderer.domElement);

      renderer.setAnimationLoop(animate);
    }

    function animate(time, frame) {
      renderer.render(scene, renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera);
    }

    init();

    (async () => {
      console.log('request device');
      display = await navigator.xr.requestDevice();
      console.log('request session');
      const session = await display.requestSession({
        exclusive: true,
      });
      display.session = session;

      // console.log('request first frame');
      session.requestAnimationFrame((timestamp, frame) => {
        renderer.vr.setSession(session, {
          frameOfReferenceType: 'stage',
        });

        const viewport = session.baseLayer.getViewport(frame.views[0]);
        const width = viewport.width;
        const height = viewport.height;

        renderer.setSize(width * 2, height);

        renderer.setAnimationLoop(null);

        renderer.vr.enabled = true;
        renderer.vr.setDevice(display);
        renderer.vr.setAnimationLoop(animate);

        console.log('running!');
      });
    })();

    const server = window.browser.http.createServer((req, res) => {
      console.log('got request', req.url);

      let match;
      if (req.url === '/') {
        res.statusCode = 302;
        res.setHeader('Location', '/examples/cameramesh_client.html');
        res.end();
      } else if (match = req.url.match(/\.(html|js|png)$/)) {
        fetch('file:///package' + req.url)
          .then(proxyRes => {
            if (proxyRes.ok) {
              return proxyRes.arrayBuffer()
                .then(arrayBuffer => {
                  const type = (() => {
                    switch (match[1]) {
                      case 'html': return 'text/html';
                      case 'js': return 'application/javascript';
                      default: return 'text/plain';
                    }
                  })();
                  res.setHeader('Content-Type', type);

                  const buffer = Buffer.from(arrayBuffer);
                  res.end(buffer);
                });
            } else {
              res.statusCode = proxyRes.status;
              res.end();
              return null;
            }
          })
          .catch(err => {
            console.warn(err.stack);
            res.statusCode = 500;
            res.end();
          });
      /* } else if (match = req.url.match(/^\/mesh\/(.+)$/)) {
        const meshId = match[1];
        let tmd = terrainMeshData[meshId];
        if (tmd) {
          tmd = Buffer.from(tmd);
          res.setHeader('Content-Type', 'application/octet-stream');
          res.end(tmd);
        } else {
          res.statusCode = 404;
          res.end();
        } */
      } else {
        res.statusCode = 404;
        res.end();
      }
    });

    const wss = new window.browser.ws.Server({
      server,
    });
    wss.on('connection', c => {
      console.log('open connection');

      c.mesh = _makePlayerMesh();
      scene.add(c.mesh);

      const _sendTerrains = () => {
        const updateSpecs = [];
        for (const id in terrainMeshData) {
          const update = terrainMeshData[id];
          if (update) {
            updateSpecs.push(
              JSON.stringify({
                method: 'mesh',
                type: 'new',
                id,
              }),
              update
            );
          }
        }
        for (let i = 0; i < updateSpecs.length; i++) {
          c.send(updateSpecs[i]);
        }
      };
      const _sendPaints = () => {
        for (let i = 0; i < paintMeshes.length; i++) {
          const paintMesh = paintMeshes[i];
          const updateSpecs = [
            JSON.stringify({
              method: 'paint',
              meshId: paintMesh.meshId,
            }),
            paintMesh.getBuffer(),
          ];

          for (let j = 0; j < updateSpecs.length; j++) {
            c.send(updateSpecs[j]);
          }
        }
      };
      _sendTerrains();
      _sendPaints();

      connections.push(c);

      const _getOtherConnections = () => connections.filter(c2 => c2 !== c);

      let pendingPaintMeshId = null;
      c.on('message', data => {
        if (typeof data === 'string') {
          const message = JSON.parse(data);
          const {method} = message;

          switch (method) {
            case 'transform': {
              const {players} = message;
              const player = players[0];
              const {position, rotation, controllers} = player;
              _loadPlayerMesh(c.mesh, player);

              const otherConnections = _getOtherConnections();
              if (otherConnections.length > 0) {
                const updateSpec = {
                  method: 'transform',
                  players: [
                    {
                      type: 'update',
                      id: c.mesh.meshId,
                      position,
                      rotation,
                      controllers,
                    },
                  ],
                };
                const updateSpecString = JSON.stringify(updateSpec);

                for (let i = 0; i < otherConnections.length; i++) {
                  const c2 = otherConnections[i];

                  if (c2 !== c && c2.readyState === window.browser.ws.OPEN) {
                    c2.send(updateSpecString);
                  }
                }
              }

              break;
            }
            case 'paint': {
              const {meshId} = message;
              pendingPaintMeshId = meshId;
              break;
            }
            case 'clear': {
              _clearPaintMeshes();

              paintMesh = null;
              paintControllerIndex = -1;

              const updateSpec = {
                method: 'clear',
              };
              const updateSpecString = JSON.stringify(updateSpec);
              for (let i = 0; i < connections.length; i++) {
                const c = connections[i];

                if (c.readyState === window.browser.ws.OPEN) {
                  c.send(updateSpecString);
                }
              }
              break;
            }
            default: {
              console.warn('unknown client method', method);
              break;
            }
          }
        } else {
          if (pendingPaintMeshId) {
            const paintMesh = _getPaintMesh(pendingPaintMeshId);
            paintMesh.load(data);

            const otherConnections = _getOtherConnections();
            if (otherConnections.length > 0) {
              const updateSpecs = [
                JSON.stringify({
                  method: 'paint',
                  meshId: pendingPaintMeshId,
                }),
                data,
              ];

              for (let i = 0; i < otherConnections.length; i++) {
                const c2 = otherConnections[i];

                if (c2 !== c && c2.readyState === window.browser.ws.OPEN) {
                  c2.send(updateSpecString);
                }
              }
            }

            pendingPaintMeshId = null;
          } else {
            console.warn('out of order binary message', daata.byteLength);
          }
        }
      });
      c.on('close', () => {
        console.log('close connection');

        scene.remove(c.mesh);

        connections.splice(connections.indexOf(c), 1);

        if (connections.length > 0) {
          const updateSpec = {
            method: 'transform',
            players: [
              {
                type: 'remove',
                id: c.playerId,
              },
            ],
          };
          const updateSpecString = JSON.stringify(updateSpec);

          for (let i = 0; i < connections.length; i++) {
            const c2 = connections[i];

            if (c2 !== c && c2.readyState === window.browser.ws.OPEN) {
              c2.send(updateSpecString);
            }
          }
        }
      });
    });

    server.listen(7999, '0.0.0.0', () => {
      console.log('listening');
    });
    server.on('error', err => {
      console.warn('server error', err.stack);
    });
})();
  </script>
  </body>
</html>
